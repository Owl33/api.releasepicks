/**
 * üéØ ÌÜµÌï© Í≤åÏûÑ Î∂ÑÏÑù ÏÑúÎπÑÏä§
 * GameAnalysisService + ClassificationResultBuilder + DlcCheckResultBuilder ÌÜµÌï©
 *
 * ÌÜµÌï©Îêú Í∏∞Îä•:
 * - Í≤åÏûÑÎ™Ö Î∂ÑÏÑù Î∞è Ìå®ÌÑ¥ Ïù∏Ïãù
 * - Í≤åÏûÑ Î∂ÑÎ•ò Î∞è Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
 * - DLC Ïó≠Í≤ÄÏÉâ Î∞è Îß§Ïπ≠
 * - Í≤ÄÏÉâ Ï†ÑÎûµ ÏÉùÏÑ±
 * - Î∂ÑÎ•ò Í≤∞Í≥º ÎπåÎìú Ìå®ÌÑ¥ ÌÜµÌï©
 */

import { Logger } from '@nestjs/common';

// === ÌÉÄÏûÖ Ï†ïÏùò ===

export interface GameNameAnalysis {
  originalName: string;
  cleanedName: string;
  patterns: {
    isDlc: boolean;
    isEdition: boolean;
    isPort: boolean;
    hasSubtitle: boolean;
  };
  extractedInfo: {
    baseName: string;
    subtitle?: string;
    detectedKeywords: string[];
  };
}

export interface GameClassificationResult {
  gameType: 'main_game' | 'dlc' | 'edition' | 'port' | 'standalone';
  confidence: number;
  reason: string;
  isMainGame: boolean;
  priority: number;
  searchStrategies: string[];
}

export interface ClassificationContext {
  rawgName: string;
  parentsCount: number;
  additionsCount: number;
  hasStoreLink: boolean;
  nameAnalysis: GameNameAnalysis;
  steamType?: string;
  dlcList?: any[];
  hasFullgameInfo?: boolean;
}

export interface DlcCheckResult {
  isDlc: boolean;
  matchedDlc?: {
    steam_id: number;
    name: string;
    similarity: number;
  };
  reason: string;
}

// === ÏÉÅÏàò Ï†ïÏùò ===

const GAME_KEYWORDS = {
  DLC: [
    'dlc', 'expansion', 'add-on', 'addon', 'content pack', 'season pass',
    'episode', 'chapter', 'downloadable content', 'extra content'
  ] as readonly string[],

  EDITION: [
    'edition', 'remaster', 'remastered', 'enhanced', 'definitive',
    'complete', 'goty', 'game of the year', 'ultimate', 'deluxe',
    'premium', 'special', 'collector', 'director\'s cut'
  ] as readonly string[],

  PORT: [
    'pc port', 'steam version', 'windows edition', 'desktop',
    'hd collection', 'trilogy'
  ] as readonly string[]
};

const GAME_TYPES = {
  MAIN_GAME: 'main_game',
  DLC: 'dlc',
  EDITION: 'edition',
  PORT: 'port',
  STANDALONE: 'standalone'
} as const;

const CONFIDENCE_THRESHOLDS = {
  SIMILARITY: 0.7,
  HIGH_CONFIDENCE: 0.9,
  MEDIUM_CONFIDENCE: 0.7,
  LOW_CONFIDENCE: 0.5
} as const;

const PERFORMANCE_LIMITS = {
  DLC_CHECK_MAX_COUNT: 50,
  SIMILARITY_CALCULATION_LIMIT: 100,
  SEARCH_STRATEGIES_LIMIT: 5
} as const;

// === Î∂ÑÎ•ò Í≤∞Í≥º ÎπåÎçî ===

class ClassificationResultBuilder {
  private gameType: string = 'standalone';
  private confidence: number = 0.7;
  private reason: string = '';
  private isMainGame: boolean = true;
  private priority: number = 88;
  private searchStrategies: string[] = [];

  static rawgMainGame(additionsCount: number, context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.MAIN_GAME)
      .setConfidence(0.95)
      .setReason(`RAWG Î≥∏Ìé∏ Í≤åÏûÑ (${additionsCount}Í∞ú Ï∂îÍ∞Ä ÏΩòÌÖêÏ∏† Î≥¥Ïú†)`)
      .setMainGame(true)
      .setPriority(100)
      .setSimpleSearchStrategies(context)
      .build();
  }

  static rawgDlc(parentCount: number, context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.DLC)
      .setConfidence(0.98)
      .setReason(`DLC (${parentCount}Í∞ú Î∂ÄÎ™® Í≤åÏûÑ Ï°¥Ïû¨)`)
      .setMainGame(false)
      .setPriority(50)
      .setComplexSearchStrategies(context)
      .build();
  }

  static steamOfficialDlc(hasFullgameInfo: boolean, context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.DLC)
      .setConfidence(0.95)
      .setReason(`Steam Í≥µÏãù DLC ÌÉÄÏûÖ${hasFullgameInfo ? ' (Î≥∏Ìé∏ Ï†ïÎ≥¥ Ìè¨Ìï®)' : ''}`)
      .setMainGame(false)
      .setPriority(60)
      .setComplexSearchStrategies(context)
      .build();
  }

  static steamMainGame(dlcCount: number, context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.MAIN_GAME)
      .setConfidence(0.95)
      .setReason(`RAWG+Steam ÏùºÏπò: Î≥∏Ìé∏ Í≤åÏûÑ (Î∂ÄÎ™® Í≤åÏûÑ ÏóÜÏùå, Ï∂îÍ∞Ä ÏΩòÌÖêÏ∏† ÏóÜÏùå, Steam 'game' ÌÉÄÏûÖ, ${dlcCount}Í∞ú DLC Î≥¥Ïú†)`)
      .setMainGame(true)
      .setPriority(95)
      .setSimpleSearchStrategies(context)
      .build();
  }

  static patternDlc(subtitle: string | undefined, context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.DLC)
      .setConfidence(0.7)
      .setReason(`Í≤åÏûÑÎ™Ö DLC Ìå®ÌÑ¥: ${subtitle || 'DLC ÌÇ§ÏõåÎìú Ìè¨Ìï®'}`)
      .setMainGame(false)
      .setPriority(55)
      .setComplexSearchStrategies(context)
      .build();
  }

  static standaloneDefault(context: ClassificationContext): GameClassificationResult {
    return new ClassificationResultBuilder()
      .setGameType(GAME_TYPES.STANDALONE)
      .setConfidence(0.85)
      .setReason('Îã®ÎèÖ Î≥∏Ìé∏ Í≤åÏûÑ (Ï∂îÍ∞Ä ÏΩòÌÖêÏ∏†/Î∂ÄÎ™® Í≤åÏûÑ/ÌäπÏàò Ìå®ÌÑ¥ ÏóÜÏùå)')
      .setMainGame(true)
      .setPriority(88)
      .setSimpleSearchStrategies(context)
      .build();
  }

  private setGameType(gameType: string): this {
    this.gameType = gameType;
    return this;
  }

  private setConfidence(confidence: number): this {
    this.confidence = confidence;
    return this;
  }

  private setReason(reason: string): this {
    this.reason = reason;
    return this;
  }

  private setMainGame(isMainGame: boolean): this {
    this.isMainGame = isMainGame;
    return this;
  }

  private setPriority(priority: number): this {
    this.priority = priority;
    return this;
  }

  private setSimpleSearchStrategies(context: ClassificationContext): this {
    this.searchStrategies = [context.rawgName];
    return this;
  }

  private setComplexSearchStrategies(context: ClassificationContext): this {
    this.searchStrategies = GameAnalysisService.generateSearchStrategies(context);
    return this;
  }

  private build(): GameClassificationResult {
    return {
      gameType: this.gameType as any,
      confidence: this.confidence,
      reason: this.reason,
      isMainGame: this.isMainGame,
      priority: this.priority,
      searchStrategies: this.searchStrategies
    };
  }
}

// === DLC Ï≤¥ÌÅ¨ Í≤∞Í≥º ÎπåÎçî ===

class DlcCheckResultBuilder {
  static noDlcList(): DlcCheckResult {
    return {
      isDlc: false,
      reason: 'DLC Î™©Î°ù ÏóÜÏùå',
    };
  }

  static tooManyDlcs(dlcCount: number): DlcCheckResult {
    return {
      isDlc: false,
      reason: `DLC Î™©Î°ùÏù¥ ÎÑàÎ¨¥ ÎßéÏùå (${dlcCount}Í∞ú)`,
    };
  }

  static matchFound(steamId: number, name: string, similarity: number): DlcCheckResult {
    return {
      isDlc: true,
      matchedDlc: {
        steam_id: steamId,
        name: name,
        similarity: similarity,
      },
      reason: `DLC Î™©Î°ùÏóêÏÑú Î∞úÍ≤¨: "${name}" (Ïú†ÏÇ¨ÎèÑ: ${(similarity * 100).toFixed(1)}%)`,
    };
  }

  static noMatchFound(dlcCount: number): DlcCheckResult {
    return {
      isDlc: false,
      reason: `DLC Î™©Î°ù ${dlcCount}Í∞ú Ï§ë ÏùºÏπòÌïòÎäî Í≤åÏûÑ ÏóÜÏùå`,
    };
  }

  static searchError(originalGameName: string, errorMessage: string): DlcCheckResult {
    return {
      isDlc: false,
      reason: `DLC Ïó≠Í≤ÄÏÉâ Ïò§Î•ò: ${errorMessage}`,
    };
  }
}

// === Î©îÏù∏ Í≤åÏûÑ Î∂ÑÏÑù ÏÑúÎπÑÏä§ ===

export class GameAnalysisService {
  private static readonly logger = new Logger(GameAnalysisService.name);

  /**
   * Í≤åÏûÑÎ™Ö Ìå®ÌÑ¥ Î∂ÑÏÑù
   */
  static analyzeGameName(gameName: string): GameNameAnalysis {
    const originalName = gameName.trim();

    // DLC Ìå®ÌÑ¥ Ï≤¥ÌÅ¨
    const isDlc = this.hasKeywords(originalName, GAME_KEYWORDS.DLC);
    const isEdition = this.hasKeywords(originalName, GAME_KEYWORDS.EDITION);
    const isPort = this.hasKeywords(originalName, GAME_KEYWORDS.PORT);

    // Î∂ÄÏ†úÎ™© Ï∂îÏ∂ú
    const colonIndex = originalName.indexOf(':');
    const dashIndex = originalName.indexOf(' - ');
    let baseName = originalName;
    let subtitle: string | undefined = undefined;

    if (colonIndex > 0) {
      baseName = originalName.substring(0, colonIndex).trim();
      subtitle = originalName.substring(colonIndex + 1).trim();
    } else if (dashIndex > 0) {
      baseName = originalName.substring(0, dashIndex).trim();
      subtitle = originalName.substring(dashIndex + 3).trim();
    }

    // Ï†ïÎ¶¨Îêú Ïù¥Î¶Ñ ÏÉùÏÑ±
    let cleanedName = originalName;
    if (isDlc && subtitle) {
      cleanedName = baseName;
    }

    // Í∞êÏßÄÎêú ÌÇ§ÏõåÎìúÎì§
    const detectedKeywords: string[] = [];
    if (isDlc) detectedKeywords.push(...GAME_KEYWORDS.DLC.filter(kw => originalName.toLowerCase().includes(kw)));
    if (isEdition) detectedKeywords.push(...GAME_KEYWORDS.EDITION.filter(kw => originalName.toLowerCase().includes(kw)));
    if (isPort) detectedKeywords.push(...GAME_KEYWORDS.PORT.filter(kw => originalName.toLowerCase().includes(kw)));

    return {
      originalName,
      cleanedName,
      patterns: {
        isDlc,
        isEdition,
        isPort,
        hasSubtitle: !!subtitle,
      },
      extractedInfo: {
        baseName,
        subtitle,
        detectedKeywords,
      },
    };
  }

  /**
   * Í≤åÏûÑ Î∂ÑÎ•ò
   */
  static classifyGame(context: ClassificationContext): GameClassificationResult {
    const { rawgName, parentsCount, additionsCount, hasStoreLink, nameAnalysis, steamType, dlcList, hasFullgameInfo } = context;

    // RAWG Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î∂ÑÎ•ò (ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ)
    if (parentsCount > 0 && nameAnalysis.patterns.isDlc) {
      return ClassificationResultBuilder.rawgDlc(parentsCount, context);
    }

    if (parentsCount === 0 && additionsCount > 0 && hasStoreLink) {
      return ClassificationResultBuilder.rawgMainGame(additionsCount, context);
    }

    // Steam Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î∂ÑÎ•ò
    if (steamType === 'dlc') {
      return ClassificationResultBuilder.steamOfficialDlc(!!hasFullgameInfo, context);
    }

    if (steamType === 'game' && parentsCount === 0 && additionsCount === 0) {
      const dlcCount = dlcList?.length || 0;
      return ClassificationResultBuilder.steamMainGame(dlcCount, context);
    }

    // Ìå®ÌÑ¥ Í∏∞Î∞ò Î∂ÑÎ•ò
    if (nameAnalysis.patterns.isDlc) {
      return ClassificationResultBuilder.patternDlc(nameAnalysis.extractedInfo.subtitle, context);
    }

    // Í∏∞Î≥∏ Î∂ÑÎ•ò
    return ClassificationResultBuilder.standaloneDefault(context);
  }

  /**
   * Í≤ÄÏÉâ Ï†ÑÎûµ ÏÉùÏÑ±
   */
  static generateSearchStrategies(context: ClassificationContext): string[] {
    const strategies: string[] = [];
    const { rawgName, nameAnalysis } = context;

    strategies.push(rawgName);

    if (nameAnalysis.patterns.isDlc || nameAnalysis.patterns.isEdition || nameAnalysis.patterns.isPort) {
      if (nameAnalysis.cleanedName && nameAnalysis.cleanedName !== rawgName) {
        strategies.push(nameAnalysis.cleanedName);
      }

      if (nameAnalysis.extractedInfo.baseName && nameAnalysis.extractedInfo.baseName !== rawgName) {
        strategies.push(nameAnalysis.extractedInfo.baseName);
      }
    }

    return [...new Set(strategies)].filter(s => s && s.length >= 3).slice(0, PERFORMANCE_LIMITS.SEARCH_STRATEGIES_LIMIT);
  }

  /**
   * DLC Ïó≠Í≤ÄÏÉâ
   */
  static async checkIfGameIsDlcInList(dlcList: any[], targetGameName: string): Promise<DlcCheckResult> {
    if (!dlcList || dlcList.length === 0) {
      return DlcCheckResultBuilder.noDlcList();
    }

    if (dlcList.length > PERFORMANCE_LIMITS.DLC_CHECK_MAX_COUNT) {
      return DlcCheckResultBuilder.tooManyDlcs(dlcList.length);
    }

    try {
      let bestMatch: { steamId: number; name: string; similarity: number } | null = null;

      for (const dlcItem of dlcList.slice(0, PERFORMANCE_LIMITS.SIMILARITY_CALCULATION_LIMIT)) {
        const similarity = this.calculateSimilarity(targetGameName, dlcItem.name);

        if (similarity >= CONFIDENCE_THRESHOLDS.SIMILARITY) {
          if (!bestMatch || similarity > bestMatch.similarity) {
            bestMatch = {
              steamId: dlcItem.steam_id || dlcItem.appid,
              name: dlcItem.name,
              similarity
            };
          }
        }
      }

      if (bestMatch) {
        return DlcCheckResultBuilder.matchFound(bestMatch.steamId, bestMatch.name, bestMatch.similarity);
      }

      return DlcCheckResultBuilder.noMatchFound(dlcList.length);

    } catch (error) {
      return DlcCheckResultBuilder.searchError(targetGameName, error?.message || String(error));
    }
  }

  /**
   * Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
   */
  private static calculateSimilarity(str1: string, str2: string): number {
    const normalize = (str: string) => str.toLowerCase().replace(/[^a-z0-9]/g, '');
    const a = normalize(str1);
    const b = normalize(str2);

    if (a === b) return 1.0;
    if (a.includes(b) || b.includes(a)) return 0.8;

    const len = Math.max(a.length, b.length);
    if (len === 0) return 1.0;

    const distance = this.levenshteinDistance(a, b);
    return Math.max(0, (len - distance) / len);
  }

  /**
   * Î†àÎ≤§ÏäàÌÉÄÏù∏ Í±∞Î¶¨ Í≥ÑÏÇ∞
   */
  private static levenshteinDistance(str1: string, str2: string): number {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,
          matrix[j - 1][i] + 1,
          matrix[j - 1][i - 1] + indicator,
        );
      }
    }

    return matrix[str2.length][str1.length];
  }

  /**
   * ÌÇ§ÏõåÎìú Ìè¨Ìï® Ïó¨Î∂Ä Ï≤¥ÌÅ¨
   */
  private static hasKeywords(text: string, keywords: readonly string[]): boolean {
    const lowerText = text.toLowerCase();
    return keywords.some(keyword => lowerText.includes(keyword.toLowerCase()));
  }
}